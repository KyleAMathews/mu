Mu: a world where any manual test can be easily automated

  keyboard input
  printing to screen
  disk filling up
  performance metrics
  race conditions
  fault tolerance
  ...

Collecting all possible scenarios considered will hopefully make the global
structure of programs more apparent. More details: http://akkartik.github.io/mu

== Taking mu for a spin

Prerequisites: Racket from http://racket-lang.org

  $ cd mu
  $ git clone http://github.com/arclanguage/anarki

Now try a test program.

  $ cat x.mu  # simple example to add two numbers
  (main
    ((x integer) <- copy (1 literal))
    ((y integer) <- copy (3 literal))
    ((z integer) <- add (x integer) (y integer))
  )

  $ ./anarki/arc mu.arc x.mu
  #hash((1 . 1) (2 . 3) (3 . 4))  # state of simulated memory after executing x.mu

Location z contains the sum of locations x and y.
(You have to imagine that location 3 maps to 'z' for now, sorry..)

Another example, this time with concurrency.

  $ ./anarki/arc mu.arc fork.mu

Notice that it repeatedly prints either '34' or '35' at random. Hit ctrl-c to
stop.

== Now dive in

Try running the tests:

  $ ./anark/arc mu.arc.t
  #t  # all tests passed!

Now start reading mu.arc.t. A colorized copy of it is at mu.arc.t.html and
http://akkartik.github.io/mu.
